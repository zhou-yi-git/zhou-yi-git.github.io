<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.110.0"><meta name=generator content="Relearn 5.11.1+tip"><meta name=description content="Documentation for Hugo Relearn Theme"><meta name=author content="waouooo"><title>六大设计原则 :: 个人博客</title><link href=https://zhou-yi-git.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/index.html rel=canonical type=text/html title="六大设计原则 :: 个人博客"><link href=../../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/index.xml rel=alternate type=application/rss+xml title="六大设计原则 :: 个人博客"><link href=../../css/fontawesome-all.min.css?1676435289 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/fontawesome-all.min.css?1676435289 rel=stylesheet></noscript><link href=../../css/auto-complete.css?1676435289 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/auto-complete.css?1676435289 rel=stylesheet></noscript><link href=../../css/perfect-scrollbar.min.css?1676435289 rel=stylesheet><link href=../../css/nucleus.css?1676435289 rel=stylesheet><link href=../../css/fonts.css?1676435289 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/fonts.css?1676435289 rel=stylesheet></noscript><link href=../../css/theme.css?1676435289 rel=stylesheet><link href=../../css/theme-relearn-light.css?1676435289 rel=stylesheet id=variant-style><link href=../../css/ie.css?1676435289 rel=stylesheet><link href=../../css/variant.css?1676435289 rel=stylesheet><link href=../../css/print.css?1676435289 rel=stylesheet media=print><link href=../../css/format-print.css?1676435289 rel=stylesheet><script src=../../js/url.js?1676435289></script>
<script src=../../js/variant.js?1676435289></script>
<script>window.index_js_url="../../index.search.js";var root_url="../../",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="复制到剪贴板",window.T_Copied_to_clipboard="复制到剪贴板！",window.T_Copy_link_to_clipboard="将链接复制到剪贴板",window.T_Link_copied_to_clipboard="链接复制到剪贴板！",window.T_No_results_found="找不到\u0022{0}\u0022的结果",window.T_N_results_found="为\u0022{0}\u0022找到 {1} 个结果",baseUriFull="https://zhou-yi-git.github.io/",window.variants&&variants.init(["relearn-light","relearn-dark","learn","neon","blue","green","red"])</script></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=../../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/index.html><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable dir=ltr><div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle class=topbar-link title='导航 (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=../../index.html><span itemprop=name>个人博客</span></a><meta itemprop=position content="1">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=../../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html><span itemprop=name>设计模式</span></a><meta itemprop=position content="2">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>六大设计原则</span><meta itemprop=position content="3"></li></ol></div></div></nav><main id=body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><div id=head-tags></div><article class=default><h1 id=六大设计原则>六大设计原则</h1><h1 id=六大设计原则>六大设计原则</h1><p>[toc]</p><h3 id=单一职责原则-single-responsibility-principle-srp>单一职责原则 (Single Responsibility Principle: SRP)</h3><h4 id=定义应该有且仅有一个原因引起类的变更-适用范围接口方法类>定义：应该有，且仅有一个原因引起类的变更 （适用范围，接口，方法，类）</h4><blockquote><p>“There should never be more than one reason for a class to change.”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books.</p><p>定义：应该有，且仅有一个原因引起类的变更 （适用范围，接口，方法，类）</p></blockquote><h4 id=建议-对于单一职责原则我的建议是接口一定要做到单一职责类的设计尽量做到只有一个原因引起变化一个方法尽可能做一件事情>建议： <code>对于单一职责原则，我的建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化，一个方法尽可能做一件事情</code></h4><h4 id=单一职责的好处>单一职责的好处：</h4><ul><li><p>类的复杂性降低实现什么职责都有清晰明确的定义</p></li><li><p>可读性提高 （因为降低了类的复杂性）</p></li><li><p>可维护性提高（因为可读性提高了）</p></li><li><p>变更引起的风险降低：</p><p>接口的单一职责做的好，一个接口的修改只对相应的实现类有影响，对系统的拓展性与可维护性都有很大的帮助</p></li></ul><h3 id=里氏替换原则-liskov-substitution-principle-lsp>里氏替换原则 (Liskov Substitution Principle: LSP)</h3><h4 id=定义所有引用基类的地方必须能透明地使用其子类的对象>定义：所有引用基类的地方必须能透明地使用其子类的对象</h4><blockquote><p>定义一：</p><p>“If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books.</p><p>定义二：</p><p>“Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）</p><p>第二使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books.</p></blockquote><h4 id=里氏替换原则为良好的继承定义了规范>里氏替换原则为良好的继承定义了规范</h4><ul><li><p>子类必须完全实现父类的方法</p><ol><li><p>“在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则”</p></li><li><p>“如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承”</p></li></ol></li><li><p>子类可以有自己的个性</p></li><li><p>覆盖或实现父类的方法时输入参数可以被放大: 子类方法的前置条件必须与超类中被复写的方法的前置条件相同或更宽松</p><p>如果Father类的输入参数类型宽于子类的输入参数类型，会出现父类存在的地方，子类就未必可以存在，因为一旦把子类作为参数传入，调用者就很可能进入子类的方法范畴。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 父类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Father</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Collection</span> <span class=nf>doSomething</span><span class=o>(</span><span class=n>HashMap</span> <span class=n>map</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;父类被执行...&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>map</span><span class=o>.</span><span class=na>values</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 子类的输入参数是Map类型，也就是说子类的输入参数类型的范围扩大了
</span></span></span><span class=line><span class=cl><span class=cm> * 子类代替父类传递到调用者中，子类的方法永远都不会被执行
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Son</span> <span class=kd>extends</span> <span class=n>Father</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//放大输入参数类型, 子类的方法永远不会执行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=n>Collection</span> <span class=nf>doSomething</span><span class=o>(</span><span class=n>Map</span> <span class=n>map</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;子类被执行...&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>map</span><span class=o>.</span><span class=na>values</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 场景类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Client</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>invoker</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//父类存在的地方，子类就应该能够存在
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Father</span> <span class=n>f</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Father</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>//Son f = new Son();
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>HashMap</span> <span class=n>map</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span><span class=o>.</span><span class=na>doSomething</span><span class=o>(</span><span class=n>map</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>invoker</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Note：<code>宽于基类，则子类的复写方法实际为方法重载，若如参为父类方法的类型，则子类方法不会被调用到，因其直接调用了其父类的方法</code></p><blockquote><p>“采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books.</p></blockquote></li><li><p>复写或实现父类的方法时输出结果可以被缩小</p><p>父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类</p></li></ul><h4 id=最佳实践>最佳实践：</h4><blockquote><p>“在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books.</p></blockquote><h3 id=依赖倒置原则-dependence-inversion-principle-dip>依赖倒置原则 (Dependence Inversion Principle: DIP)</h3><h4 id=定义>定义</h4><ol><li>高层模块不应该依赖底层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节；</li><li>细节应该依赖抽象；</li></ol><blockquote><p>“High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books.</p><p>“依赖倒置原则在Java语言中的表现就是：</p><p>● 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</p><p>● 接口或抽象类不依赖于实现类；</p><p>● 实现类依赖接口或抽象类。”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books.</p></blockquote><footer class=footline><div id=comments><style>#comment{padding:8rem 0 2rem}#comment .vemoji{max-width:1.5em;max-height:1.5em}</style><div id=comment><script src=https://giscus.app/client.js data-repo=zhou-yi-git/zhou-yi-git.github.io data-repo-id=R_kgDOI0eMkg data-category=Announcements data-category-id=DIC_kwDOI0eMks4CT2cD data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous data-term=1046 async></script></div><noscript>Please enable JavaScript to view the comments powered by giscus.</noscript></div></footer></article></div></main></div><script src=../../js/clipboard.min.js?1676435289 defer></script>
<script src=../../js/perfect-scrollbar.min.js?1676435289 defer></script>
<script src=../../js/featherlight.min.js?1676435289 defer></script>
<script src=../../js/theme.js?1676435289 defer></script></body></html>