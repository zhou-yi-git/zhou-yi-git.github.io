<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.110.0"><meta name=generator content="Relearn 5.11.1+tip"><meta name=description content="Documentation for Hugo Relearn Theme"><meta name=author content="waouooo"><title>单例模式 :: 个人博客</title><link href=https://zhou-yi-git.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/index.html rel=canonical type=text/html title="单例模式 :: 个人博客"><link href=../../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/index.xml rel=alternate type=application/rss+xml title="单例模式 :: 个人博客"><link href=../../css/fontawesome-all.min.css?1676435289 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/fontawesome-all.min.css?1676435289 rel=stylesheet></noscript><link href=../../css/auto-complete.css?1676435289 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/auto-complete.css?1676435289 rel=stylesheet></noscript><link href=../../css/perfect-scrollbar.min.css?1676435289 rel=stylesheet><link href=../../css/nucleus.css?1676435289 rel=stylesheet><link href=../../css/fonts.css?1676435289 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/fonts.css?1676435289 rel=stylesheet></noscript><link href=../../css/theme.css?1676435289 rel=stylesheet><link href=../../css/theme-relearn-light.css?1676435289 rel=stylesheet id=variant-style><link href=../../css/ie.css?1676435289 rel=stylesheet><link href=../../css/variant.css?1676435289 rel=stylesheet><link href=../../css/print.css?1676435289 rel=stylesheet media=print><link href=../../css/format-print.css?1676435289 rel=stylesheet><script src=../../js/url.js?1676435289></script>
<script src=../../js/variant.js?1676435289></script>
<script>window.index_js_url="../../index.search.js";var root_url="../../",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="复制到剪贴板",window.T_Copied_to_clipboard="复制到剪贴板！",window.T_Copy_link_to_clipboard="将链接复制到剪贴板",window.T_Link_copied_to_clipboard="链接复制到剪贴板！",window.T_No_results_found="找不到\u0022{0}\u0022的结果",window.T_N_results_found="为\u0022{0}\u0022找到 {1} 个结果",baseUriFull="https://zhou-yi-git.github.io/",window.variants&&variants.init(["relearn-light","relearn-dark","learn","neon","blue","green","red"])</script></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=../../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/index.html><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable dir=ltr><div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle class=topbar-link title='导航 (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=../../index.html><span itemprop=name>个人博客</span></a><meta itemprop=position content="1">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=../../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html><span itemprop=name>设计模式</span></a><meta itemprop=position content="2">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>单例模式</span><meta itemprop=position content="3"></li></ol></div></div></nav><main id=body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><div id=head-tags></div><article class=default><h1 id=单例模式>单例模式</h1><h1 id=单例模式>单例模式</h1><h3 id=定义>定义：</h3><p>“确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例”</p><h3 id=通用代码>通用代码：</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Singleton</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 定义的时候初始化对象/在static体重定义/在get方法中定义（此时的get方法加synchronized 修饰）  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>  
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Singleton</span> <span class=n>singleton</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 私有化构造类，限制产生多个对象  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 获取实例对象  
</span></span></span><span class=line><span class=cl><span class=cm>     *  
</span></span></span><span class=line><span class=cl><span class=cm>     * @return  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>  
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getSingleton</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>singleton</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 类中其他方法，尽量是static  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>    
</span></span><span class=line><span class=cl>     <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>doSomething</span><span class=o>(){</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=优点>优点</h3><ul><li>减少内存开销，避免频繁创建销毁时的性能损耗（创建销毁性能无法优化）</li><li>避免资源多重占用（例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作）</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问</li></ul><h3 id=缺点>缺点</h3><ul><li>拓展困难，因为一般没有接口(接口对单例模式没有意义)</li><li>不利于测试，在单例模式创建之前不能完成测试</li><li>与单一职责原则冲突</li></ul><h3 id=业务例子>业务例子</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 线程池  
</span></span></span><span class=line><span class=cl><span class=cm> *  
</span></span></span><span class=line><span class=cl><span class=cm> * @author robinson  
</span></span></span><span class=line><span class=cl><span class=cm> * 2021/9/28 15:19 
</span></span></span><span class=line><span class=cl><span class=cm> * 
</span></span></span><span class=line><span class=cl><span class=cm> **/</span>
</span></span><span class=line><span class=cl><span class=nd>@Slf4j</span>  
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ExecutorUtil</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 核心线程数  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>THREAD_CORE_POOL_SIZE</span> <span class=o>=</span> <span class=mi>5</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 队列容量  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>THREAD_QUEUE_CAPACITY</span> <span class=o>=</span> <span class=mi>1024</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>ThreadPoolExecutor</span> <span class=n>executor</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 私有构造方法，防止初始化  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>ExecutorUtil</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 获取线程池  
</span></span></span><span class=line><span class=cl><span class=cm>     *  
</span></span></span><span class=line><span class=cl><span class=cm>     * @return ThreadPoolExecutor  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>    
</span></span><span class=line><span class=cl>     <span class=kd>public</span> <span class=kd>static</span> <span class=kd>synchronized</span> <span class=n>ThreadPoolExecutor</span> <span class=nf>getExecutor</span><span class=o>(</span><span class=n>String</span> <span class=n>threadPoolName</span><span class=o>)</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=kc>null</span> <span class=o>==</span> <span class=n>executor</span><span class=o>)</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>            <span class=n>ThreadFactory</span> <span class=n>threadFactory</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadFactoryBuilder</span><span class=o>().</span><span class=na>setNameFormat</span><span class=o>(</span><span class=n>threadPoolName</span> <span class=o>+</span> <span class=s>&#34;-%d&#34;</span><span class=o>).</span><span class=na>build</span><span class=o>();</span>  
</span></span><span class=line><span class=cl>            <span class=n>executor</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadPoolExecutor</span><span class=o>(</span><span class=n>THREAD_CORE_POOL_SIZE</span><span class=o>,</span> <span class=n>THREAD_CORE_POOL_SIZE</span><span class=o>,</span>  
</span></span><span class=line><span class=cl>                    <span class=mi>0</span><span class=n>L</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>MILLISECONDS</span><span class=o>,</span>  
</span></span><span class=line><span class=cl>                    <span class=c1>// 定义队列大小，防止占用内存过大  
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>new</span> <span class=n>LinkedBlockingQueue</span><span class=o>&lt;&gt;(</span><span class=n>THREAD_QUEUE_CAPACITY</span><span class=o>),</span>  
</span></span><span class=line><span class=cl>                    <span class=n>threadFactory</span><span class=o>,</span>  
</span></span><span class=line><span class=cl>                    <span class=c1>// 使用CallerRunsPolicy() 保证所有任务不被丢弃  
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>new</span> <span class=n>ThreadPoolExecutor</span><span class=o>.</span><span class=na>CallerRunsPolicy</span><span class=o>());</span>  
</span></span><span class=line><span class=cl>        <span class=o>}</span>  
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>executor</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=其他实现>其他实现</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//懒汉式
</span></span></span><span class=line><span class=cl><span class=c1>//实现方式一：线程不安全
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nf>Singleton</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=c1>//私有化的构造器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>(){}</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>instance</span> <span class=o>==</span> <span class=kc>null</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=n>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>//实现方式二：线程安全
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nf>Singleton</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=c1>//私有化的构造器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>(){}</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>synchronized</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>instance</span> <span class=o>==</span> <span class=kc>null</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=n>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>//实现方式三：双重检查锁→推荐
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  多线程下，可能出现空指针问题，原因：JVM的优化和指令重排
</span></span></span><span class=line><span class=cl><span class=cm>  解决：volatile
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nf>Singleton</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=c1>//私有化的构造器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>(){}</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>volatile</span> <span class=n>Singleton</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>instance</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>){</span><span class=c1>//iyci判断，如果instance值不为空，不需要强占锁，直接返回对象
</span></span></span><span class=line><span class=cl><span class=c1></span>           <span class=kd>synchronized</span><span class=o>(</span><span class=n>Singleton</span><span class=o>.</span><span class=na>class</span><span class=o>){</span>
</span></span><span class=line><span class=cl>             <span class=k>if</span><span class=o>(</span><span class=n>instance</span> <span class=o>==</span> <span class=kc>null</span><span class=o>){</span><span class=c1>//第二次判断
</span></span></span><span class=line><span class=cl><span class=c1></span>               <span class=n>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>          <span class=o>}</span>
</span></span><span class=line><span class=cl>           <span class=o>}</span>     
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//实现方式四：静态内部类→推荐
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  JVM加载外部类的过程中，不会加载静态内部类，只有内部类的属性、方法调用时才会被加载→解决指令重排问题
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nf>Singleton</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=c1>//私有化的构造器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>(){}</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=kd>static</span> <span class=n>clss</span> <span class=n>SingletonHoler</span><span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//内部类中声明并初始化外部类的对象
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Singleton</span> <span class=n>INSTANCE</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>SingletonHolder</span><span class=o>.</span><span class=na>INSTANCE</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 解决序列化破坏
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nf>Singleton</span><span class=o>()</span> <span class=kd>implements</span> <span class=n>Serializable</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 私有化的构造器  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>()</span> <span class=o>{};</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>SingletonHolder</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>        <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>         * 内部类中声明并初始化外部类的对象  
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>  
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Singleton</span> <span class=n>INSTANCE</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>SingletonHolder</span><span class=o>.</span><span class=na>INSTANCE</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 当进行反序列化时，会自动调用该方法  
</span></span></span><span class=line><span class=cl><span class=cm>     * @return  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>  
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Object</span> <span class=nf>readResolve</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>SingletonHolder</span><span class=o>.</span><span class=na>INSTANCE</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 解决序列化破坏  
</span></span></span><span class=line><span class=cl><span class=cm> */</span>  
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nf>Singleton</span><span class=o>(){</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kt>boolean</span> <span class=n>flag</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span> <span class=c1>// 实际开发中会用加密过的一个标志  
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>    <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>     * 私有化的构造器  
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>flag</span><span class=o>)</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=s>&#34;不能用反射破坏单例模式&#34;</span><span class=o>);</span>  
</span></span><span class=line><span class=cl>        <span class=o>}</span>  
</span></span><span class=line><span class=cl>        <span class=n>flag</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>SingletonHolder</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>        <span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm>         * 内部类中声明并初始化外部类的对象  
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>  
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Singleton</span> <span class=n>INSTANCE</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>SingletonHolder</span><span class=o>.</span><span class=na>INSTANCE</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=总结>总结</h3><p>单例模式是23个模式中比较简单的模式，应用也非常广泛，如在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理这些Bean的生命期，决定什么时候创建出来，什么时候销毁，销毁的时候要如何处理，等等。如果采用非单例模式（Prototype类型），则Bean初始化后的管理交由J2EE容器，Spring容器不再跟踪管理Bean的生命周期</p><footer class=footline><div id=comments><style>#comment{padding:8rem 0 2rem}#comment .vemoji{max-width:1.5em;max-height:1.5em}</style><div id=comment><script src=https://giscus.app/client.js data-repo=zhou-yi-git/zhou-yi-git.github.io data-repo-id=R_kgDOI0eMkg data-category=Announcements data-category-id=DIC_kwDOI0eMks4CT2cD data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous data-term=1046 async></script></div><noscript>Please enable JavaScript to view the comments powered by giscus.</noscript></div></footer></article></div></main></div><script src=../../js/clipboard.min.js?1676435289 defer></script>
<script src=../../js/perfect-scrollbar.min.js?1676435289 defer></script>
<script src=../../js/featherlight.min.js?1676435289 defer></script>
<script src=../../js/theme.js?1676435289 defer></script></body></html>